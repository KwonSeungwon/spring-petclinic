<IOC(Inversion of Control)>
일반적인 (의존성에 대한) 제어권: “내가 사용할 의존성은 내가 만든다.”
-- 정리하자면 A라는 클래스가 B라는 클래스에 의존적이라면 예) 부모(B)와 자식관계(A) 인경우 spring IOC를 통해 의존적인 관계를 만드는 것
※ 싱글톤을 이용하여 구현됨.
class OwnerController {
   private OwnerRepository repository = new OwnerRepository();
}
IoC: “내가 사용할 의존성을 누군가 알아서 주겠지”
내가 사용할 의존성의 타입(또는 인터페이스)만 맞으면 어떤거든 상관없다.
그래야 내 코드 테스트 하기도 편하지.

class OwnerController {
   private OwnerRepository repo;

   public OwnerController(OwnerRepository repo) {
       this.repo = repo;
   }

   // repo를 사용합니다.
}

class OwnerControllerTest {
   @Test
   public void create() {
         OwnerRepository repo = new OwnerRepository();
         OwnerController controller = new OwnerController(repo);
   }
}

참고
https://martinfowler.com/articles/injection.html
<IoC (Inversion of Control) 컨테이너>
컨테이너(Container) : 개발자가 작성한 코드의 처리과정을 위임받은 독립적인 존재
빈(bean) : 컨테이너가 관리하는 객체(클래스) Spring IOC를 통해 인스턴스화, 관리, 생성됨. Bean Container은 Bean객체를 사용할 수 있게해줌

빈(bean)을 만들고 엮어주며 제공해준다.
빈 설정
이름 또는 ID
타입
스코프
아이러니하게도 컨테이너를 직접 쓸 일은 많지 않다.

참고
https://github.com/spring-guides/understanding/tree/master/application-context
https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/ApplicationContext.html
https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/BeanFactory.html
[Bean 등록방법]
<Component Scanning>
- @Component
- @Repository
- @Service
- @Controller
- @Configuration
※ Repository의 경우 Spring JPA가 제공하는 기능이며 Repository를 extends(상속) 받고 있으면 알아서 Bean등록을 해준다.(구현체들을 만들어서 해줌)
또는 직접 일일히 XML이나 자바 설정 파일에 등록
[사용법]
- @Autowired 또는 @Inject
- 또는 ApplicationContext에서 getBean()으로 직접 꺼내거나
[특징]
- 오로지 “빈"들만 의존성 주입을 해줍니다.
[의존성 주입 (Dependency Injection)]
※ 생성자를 통한 의존성 주입 : 스프링 4.3(이상)추가 / 생성자가 1개이고 생성자로 주입받는 레퍼런스 변수들이 Bean으로 등록되었다면 의존성을 자동으로 주입해줌.
- @Autowired / @Inject를 어디에 붙일까?
- 생성자 -> spring reference에서 권장하는 전통적인 방식(의존성 주입에 필수적인 요소들을 강제적으로 생성할 수 있게 하기때문에), 순환참조가 발생할 수 있음(A,B가 둘 다 참조하는 경우 서버에러)
- 필드
- Setter
<과제>
- OwnerController에 petRepository 주입하기


[AOP]
AOP(Aspect Oriented Programming) : 관점지향프로그래밍 / 프록시 패턴으로 사용하여 구현됨.
class A {
   method a () {
           AAAA -> AAA
           오늘은 7월 4일 미국 독립 기념일이래요.
           BBBB -> BB
   }

   method b () {
           AAAA -> AAA
           저는 아침에 운동을 다녀와서 밥먹고 빨래를 했습니다.
           BBBB -> BB
   }
}

class B {
  method c() {
          AAAA -> AAA
          점심은 이거 찍느라 못먹었는데 저녁엔 제육볶음을 먹고 싶네요.
          BBBB -> BB
  }
}
모아 놓은 AAAA 와 BBBB

class A {
   method a () {
           오늘은 7월 4일 미국 독립 기념일이래요.
   }

   method b () {
           저는 아침에 운동을 다녀와서 밥먹고 빨래를 했습니다.
   }
}

class B {
  method c() {
          점심은 이거 찍느라 못먹었는데 저녁엔 제육볶음을 먹고 싶네요.
  }
}

class AAAABBBB { // 메소드 a와 b를 모아놓은 클래스(AOP)
    method aaaabbb(JoinPoint point) {
         AAAA
	  point.execute()
         BBBB
    }
}
@Transactional = AOP 기준으로 만들어진 어노테이션
Spring에서 제공하는 기능 스탑워치 : StopWatch stopwatch = new StopWatch(); -> start, end등의 메소드 존재.
[AOP 구현방법]
- 컴파일  A.java ----(AOP)---> A.class (AspectJ)
- 바이트코드 조작 A.java -> A.class ---(AOP)---> 메모리 (AspectJ)
- 프록시 패턴 (스프링 AOP)
<프록시 패턴>
- https://refactoring.guru/design-patterns/proxy

